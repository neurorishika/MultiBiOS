{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MultiBiOS Odor Delivery System","text":"\ud83e\uddea Precision Olfactometer Control for Behavioral Neuroscience \ud83e\uddea"},{"location":"#overview","title":"Overview","text":"<p>MultiBiOS (Multispecies Bilateral Odor delivery System) is a high-precision, hardware-clocked olfactometer control system designed for behavioral neuroscience experiments. It provides sub-millisecond timing control, full signal provenance, and reproducible experimental protocols.</p> <p>Key Features</p> <ul> <li>\u26a1 Sub-millisecond precision with hardware-clocked timing</li> <li>\ud83d\udd04 Bilateral control for complex comparative experiments  </li> <li>\ud83d\udcca Full signal provenance with comprehensive logging</li> <li>\ud83d\udee1\ufe0f Built-in guardrails prevent timing conflicts</li> <li>\ud83c\udfb2 Reproducible randomization via configurable seeds</li> <li>\ud83d\udcc8 Interactive visualization with Plotly integration</li> </ul>"},{"location":"#system-architecture","title":"System Architecture","text":"<p>The MultiBiOS system consists of three main components working in perfect synchronization:</p> Hardware LayerFirmware LayerSoftware Layer <ul> <li>Teensy 4.1 microcontroller for valve preloading</li> <li>TPIC6B595 shift register chains (10MHz SPI)</li> <li>NI USB-6353 for hardware-clocked timing</li> <li>Mass flow controllers for precise flow control</li> </ul> <ul> <li>Interrupt-driven architecture on Teensy 4.1</li> <li>Pattern preloading with sticky S-bit rails</li> <li>Hardware synchronization via RCK signals</li> <li>Safety interlocks and state validation</li> </ul> <ul> <li>YAML protocol compiler with timing validation</li> <li>Hardware-clocked execution via NI-DAQmx</li> <li>Real-time logging of all signals</li> <li>Interactive analysis and visualization</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Get up and running with MultiBiOS in minutes:r Delivery System</p> <p>Multispecies Bilateral Odor Delivery with sub-millisecond control and full signal provenance.</p> <p>This repository provides:</p> <ul> <li>Teensy 4.1 firmware that preloads valve patterns and commits on NI-DAQ register clocks (RCK).</li> <li>A YAML protocol that describes stimuli, triggers, and MFC setpoints with ms-level timing.</li> <li>A hardware-clocked NI USB-6353 runner that generates DO/AO, and logs MFC analog feedback (AI).</li> <li>Guardrails that reject overlapping preload\u2192commit windows at compile-time.</li> <li>Sticky S-bit rails so digital state lines reflect the system\u2019s current logical state between events.</li> <li>Interactive Plotly viewer that overlays compiled DO/AO with captured AI.</li> <li>Reproducible randomization via a configurable <code>seed</code>.</li> </ul>"},{"location":"#quickstart","title":"Quickstart","text":""},{"location":"#1-preview-mode-no-hardware-required","title":"1. Preview Mode (No Hardware Required)","text":"<pre><code># Generate and visualize a protocol without hardware\npoetry run python -m multibios.run_protocol \\\n    --yaml config/example_protocol.yaml \\\n    --hardware config/hardware.yaml \\\n    --dry-run --interactive --seed 42\n</code></pre>"},{"location":"#2-hardware-execution","title":"2. Hardware Execution","text":"<pre><code># Run on actual hardware (requires NI-DAQmx drivers)\npoetry run python -m multibios.run_protocol \\\n    --yaml config/example_protocol.yaml \\\n    --hardware config/hardware.yaml\n</code></pre>"},{"location":"#3-post-run-analysis","title":"3. Post-Run Analysis","text":"<pre><code># Visualize any completed experiment\npoetry run python -m multibios.viz_protocol data/runs/2025-08-21_14-07-33\n</code></pre>"},{"location":"#what-makes-multibios-special","title":"What Makes MultiBiOS Special?","text":""},{"location":"#hardware-clocked-precision","title":"\ud83c\udfaf Hardware-Clocked Precision","text":"<p>Unlike software-based timing systems, MultiBiOS uses dedicated hardware clocks for microsecond-precise valve control, ensuring experimental reproducibility even under system load.</p>"},{"location":"#compile-time-safety","title":"\ud83d\udd12 Compile-Time Safety","text":"<p>The protocol compiler validates all timing constraints before execution, preventing hardware conflicts and ensuring reliable operation.</p>"},{"location":"#complete-data-provenance","title":"\ud83d\udcca Complete Data Provenance","text":"<p>Every signal is logged with timestamps, providing a complete record of experimental conditions for analysis and publication.</p>"},{"location":"#reproducible-randomization","title":"\ud83c\udfb2 Reproducible Randomization","text":"<p>Configurable random seeds ensure that \"randomized\" protocols can be exactly reproduced for validation and replication studies.</p>"},{"location":"#example-protocol","title":"Example Protocol","text":"<p>Here's a simple bilateral odor presentation protocol:</p> <pre><code>protocol:\n  name: \"Bilateral Odor Test\"\n  timing:\n    sample_rate: 1000\n    seed: 42\n\nsequence:\n  - phase: \"Baseline\"\n    duration: 30000  # 30 seconds\n    times: 1\n    actions:\n      - device: \"olfactometer.left\"\n        state: \"AIR\"\n        timing: 0\n      - device: \"olfactometer.right\"  \n        state: \"AIR\"\n        timing: 0\n\n  - phase: \"Odor Presentation\"\n    duration: 60000  # 1 minute\n    times: 5\n    randomize: true\n    actions:\n      - device: \"olfactometer.left\"\n        state: \"ODOR1,ODOR2,ODOR3\"  # Randomized selection\n        timing: 0\n      - device: \"triggers.microscope\"\n        state: true\n        timing: 15000  # Trigger 15s into each trial\n</code></pre> <p>Ready to Get Started?</p> <p>Check out the Hardware Setup guide to begin building your MultiBiOS system, or explore the Protocol Specification to understand the YAML format.</p> <p>See Hardware for wiring and safety, Protocol for YAML schema, and Runner for execution and logging.</p>"},{"location":"contributing/","title":"Contributing to MultiBiOS","text":"<p>We welcome contributions from the neuroscience and engineering communities! This guide will help you get started with contributing to the MultiBiOS project.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#development-environment","title":"Development Environment","text":"<ol> <li> <p>Clone the repository: <pre><code>git clone https://github.com/neurorishika/MultiBiOS.git\ncd MultiBiOS\n</code></pre></p> </li> <li> <p>Install Poetry (if not already installed): <pre><code>curl -sSL https://install.python-poetry.org | python3 -\n</code></pre></p> </li> <li> <p>Install dependencies: <pre><code>poetry install\n</code></pre></p> </li> <li> <p>Activate the virtual environment: <pre><code>poetry shell\n</code></pre></p> </li> </ol>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":"<ol> <li> <p>Create a feature branch: <pre><code>git checkout -b feature/your-feature-name\n</code></pre></p> </li> <li> <p>Make your changes following the guidelines below</p> </li> <li> <p>Run tests: <pre><code>poetry run pytest tests/\n</code></pre></p> </li> <li> <p>Format your code: <pre><code>poetry run black multibios/\npoetry run ruff check multibios/\n</code></pre></p> </li> <li> <p>Update documentation if needed</p> </li> <li> <p>Commit and push: <pre><code>git add .\ngit commit -m \"Add: your feature description\"\ngit push origin feature/your-feature-name\n</code></pre></p> </li> <li> <p>Open a Pull Request on GitHub</p> </li> </ol>"},{"location":"contributing/#code-standards","title":"Code Standards","text":""},{"location":"contributing/#python-code","title":"Python Code","text":"<ul> <li>Formatting: Use <code>black</code> for code formatting</li> <li>Linting: Use <code>ruff</code> for linting and style checks</li> <li>Type hints: Add type annotations for new functions</li> <li>Docstrings: Document all public functions and classes</li> </ul> <pre><code>def compile_protocol(protocol_data: Dict[str, Any], seed: int = 42) -&gt; CompiledProtocol:\n    \"\"\"Compile a YAML protocol into hardware timing data.\n\n    Args:\n        protocol_data: Raw protocol dictionary from YAML\n        seed: Random seed for reproducible randomization\n\n    Returns:\n        Compiled protocol with timing arrays and device mappings\n\n    Raises:\n        ProtocolError: If protocol contains timing conflicts\n    \"\"\"\n</code></pre>"},{"location":"contributing/#firmware-code","title":"Firmware Code","text":"<ul> <li>Arduino style: Follow Arduino/C++ conventions</li> <li>Comments: Document timing-critical sections extensively</li> <li>Constants: Use meaningful names for pin assignments and timing values</li> </ul>"},{"location":"contributing/#documentation","title":"Documentation","text":"<ul> <li>Markdown: Follow standard Markdown formatting</li> <li>Examples: Include practical examples for new features</li> <li>Links: Use relative links for internal documentation references</li> </ul>"},{"location":"contributing/#testing-guidelines","title":"Testing Guidelines","text":""},{"location":"contributing/#unit-tests","title":"Unit Tests","text":"<ul> <li>Add tests in <code>tests/</code> for all new protocol features</li> <li>Test both valid and invalid inputs</li> <li>Ensure tests are deterministic (use fixed seeds)</li> <li>Test edge cases and error conditions</li> </ul> <pre><code>def test_protocol_compilation():\n    \"\"\"Test that valid protocols compile correctly.\"\"\"\n    protocol = {\n        \"protocol\": {\"name\": \"Test\", \"timing\": {\"sample_rate\": 1000}},\n        \"sequence\": [{\"phase\": \"test\", \"duration\": 1000, \"times\": 1, \"actions\": []}]\n    }\n    compiled = compile_protocol(protocol, seed=42)\n    assert compiled.total_samples == 1000\n</code></pre>"},{"location":"contributing/#integration-tests","title":"Integration Tests","text":"<ul> <li>Test complete protocol execution in dry-run mode</li> <li>Validate timing guardrails with realistic scenarios</li> <li>Test visualization generation</li> </ul>"},{"location":"contributing/#hardware-tests","title":"Hardware Tests","text":"<ul> <li>If you have access to hardware, test critical changes</li> <li>Document any hardware-specific test procedures</li> <li>Include photos/videos of test setups if helpful</li> </ul>"},{"location":"contributing/#documentation-updates","title":"Documentation Updates","text":"<p>When making changes, update relevant documentation:</p>"},{"location":"contributing/#schema-changes","title":"Schema Changes","text":"<ul> <li>Update <code>docs/protocol.md</code> with new YAML syntax</li> <li>Modify <code>config/example_protocol.yaml</code> with examples</li> <li>Update <code>config/hardware.yaml</code> if adding new device types</li> </ul>"},{"location":"contributing/#feature-additions","title":"Feature Additions","text":"<ul> <li>Add sections to appropriate documentation files</li> <li>Include practical examples and use cases</li> <li>Update the FAQ if addressing common questions</li> </ul>"},{"location":"contributing/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>Clearly document migration steps</li> <li>Update all example files</li> <li>Consider backwards compatibility options</li> </ul>"},{"location":"contributing/#contribution-types","title":"Contribution Types","text":""},{"location":"contributing/#bug-fixes","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>Include a clear description of the bug</li> <li>Provide steps to reproduce the issue</li> <li>Add a test case that would have caught the bug</li> </ul>"},{"location":"contributing/#new-features","title":"\u2728 New Features","text":"<ul> <li>Discuss major features in an issue first</li> <li>Ensure features align with project goals</li> <li>Include comprehensive tests and documentation</li> </ul>"},{"location":"contributing/#documentation-improvements","title":"\ud83d\udcda Documentation Improvements","text":"<ul> <li>Fix typos and improve clarity</li> <li>Add missing examples or explanations</li> <li>Improve formatting and organization</li> </ul>"},{"location":"contributing/#hardware-support","title":"\ud83d\udd27 Hardware Support","text":"<ul> <li>Support for new DAQ devices or valve controllers</li> <li>Additional safety features or interlocks</li> <li>Performance optimizations</li> </ul>"},{"location":"contributing/#design-principles","title":"Design Principles","text":"<p>When contributing, keep these principles in mind:</p>"},{"location":"contributing/#deterministic-behavior","title":"\ud83c\udfaf Deterministic Behavior","text":"<ul> <li>All randomization should respect the configured seed</li> <li>Timing behavior should be predictable and reproducible</li> <li>Avoid non-deterministic operations in critical paths</li> </ul>"},{"location":"contributing/#safety-first","title":"\ud83d\udee1\ufe0f Safety First","text":"<ul> <li>Hardware safety features should never be optional</li> <li>Timing guardrails prevent dangerous conditions</li> <li>Fail-safe defaults for all configuration options</li> </ul>"},{"location":"contributing/#data-provenance","title":"\ud83d\udcca Data Provenance","text":"<ul> <li>Log all relevant parameters and timing information</li> <li>Ensure experimental conditions can be exactly reproduced</li> <li>Maintain backwards compatibility for data formats</li> </ul>"},{"location":"contributing/#performance","title":"\u26a1 Performance","text":"<ul> <li>Hardware timing is critical - avoid blocking operations</li> <li>Optimize for the common case (standard protocols)</li> <li>Consider memory usage for long experiments</li> </ul>"},{"location":"contributing/#release-process","title":"Release Process","text":""},{"location":"contributing/#versioning","title":"Versioning","text":"<p>We follow semantic versioning (SemVer): - Major (X.0.0): Breaking changes to APIs or protocols - Minor (X.Y.0): New features, backwards compatible - Patch (X.Y.Z): Bug fixes, no new features</p>"},{"location":"contributing/#changelog","title":"Changelog","text":"<ul> <li>Document all changes in <code>CHANGELOG.md</code></li> <li>Include migration notes for breaking changes</li> <li>Credit all contributors</li> </ul>"},{"location":"contributing/#community-guidelines","title":"Community Guidelines","text":""},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<ul> <li>Be respectful and inclusive</li> <li>Focus on constructive feedback</li> <li>Help newcomers get started</li> <li>Celebrate contributions of all sizes</li> </ul>"},{"location":"contributing/#communication","title":"Communication","text":"<ul> <li>Use GitHub issues for bug reports and feature requests</li> <li>Tag issues appropriately (<code>bug</code>, <code>enhancement</code>, <code>documentation</code>)</li> <li>Provide sufficient context for others to understand and reproduce issues</li> </ul>"},{"location":"contributing/#recognition","title":"Recognition","text":"<p>Contributors are recognized in: - <code>AUTHORS.md</code> file in the repository - Release notes for significant contributions - Documentation credits where appropriate</p>"},{"location":"contributing/#getting-help","title":"Getting Help","text":"<ul> <li>GitHub Issues: For bugs and feature requests</li> <li>GitHub Discussions: For questions and community support</li> <li>Email: For sensitive issues or collaboration inquiries</li> </ul> <p>Thank you for contributing to MultiBiOS! Your efforts help advance neuroscience research through better experimental tools.</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#system-architecture","title":"System Architecture","text":"Why separate preload and commit? <p>The separation of preload and commit operations allows the DAQ to timestamp the commit with hardware precision and coordinate multiple valve assemblies independently. This ensures sub-millisecond timing accuracy even under system load.</p> What does the guardrail prevent? <p>The compile-time guardrail prevents overlapping \"preload\u2192commit\" windows where two assemblies would both be staged simultaneously. The Teensy firmware is designed to handle exactly one staged owner at a time for safety and reliability.</p> Why use sticky S-bits? <p>Sticky S-bits make digital rails represent the current logical state between events, which simplifies verification and downstream analysis. This provides a clear representation of what the system is actually doing at any given moment.</p>"},{"location":"faq/#timing-and-performance","title":"Timing and Performance","text":"Can I use 0.1 ms timing resolution? <p>Yes! Set <code>sample_rate: 10000</code> in your protocol configuration and ensure your USB-6353 and host computer can handle the higher sample rate. All system components (guardrails, viewer, logging) automatically scale with the sample rate.</p> What's the maximum sample rate supported? <p>The system supports up to 10 kHz (0.1 ms resolution) with the NI USB-6353. Higher rates may be possible but haven't been extensively tested. The limiting factors are typically USB bandwidth and host system performance.</p> How precise is the timing really? <p>Hardware-clocked events have microsecond precision determined by the NI-DAQ clock. Software events (like protocol phase transitions) have millisecond precision. The sticky S-bit approach ensures valve states are always synchronized to the hardware clock.</p>"},{"location":"faq/#hardware-and-setup","title":"Hardware and Setup","text":"Can I use a different DAQ device? <p>The system is designed around the NI USB-6353's capabilities, but could potentially be adapted to other NI-DAQ devices with sufficient digital I/O and analog channels. This would require modifications to the hardware configuration and possibly the runner code.</p> How many valve assemblies can I control? <p>The current firmware supports 4 shift register chains (olfactometer_left, olfactometer_right, switchvalve_left, switchvalve_right), each controlling 8 valves. This could be extended by modifying the firmware and hardware configuration.</p> What if I need more trigger outputs? <p>The current system provides microscope triggers and continuous camera triggers. Additional trigger types can be added by modifying the hardware mapping and protocol schema. The NI-DAQ has additional digital output channels available.</p>"},{"location":"faq/#protocol-development","title":"Protocol Development","text":"How do I test protocols without hardware? <p>Use the <code>--dry-run</code> flag with the runner. This generates all the timing data and visualizations without attempting to communicate with actual hardware. Perfect for protocol development and debugging.</p> Can I have overlapping device actions? <p>Yes, but with constraints. Different device types (olfactometers, MFCs, triggers) can have overlapping actions. However, the same device cannot have overlapping state changes, and valve assemblies cannot have overlapping preload windows.</p> How does randomization work? <p>When <code>randomize: true</code> is set for a phase with multi-state device actions, the system shuffles the state list using the configured seed. This ensures reproducible \"randomization\" - the same seed always produces the same sequence.</p>"},{"location":"faq/#troubleshooting","title":"Troubleshooting","text":"Why do I get timing guardrail errors? <p>Guardrail errors occur when valve switching events are scheduled too close together. Check that your <code>preload_lead_ms</code> and <code>setup_hold_samples</code> settings provide sufficient margins between events. The error message will indicate which specific timing constraint was violated.</p> My MFC readings seem noisy - is this normal? <p>Some noise in MFC analog readings is normal. The system logs raw ADC values for full provenance. Consider the noise level relative to your experimental requirements and use appropriate filtering in post-analysis if needed.</p> Can I modify the protocol during execution? <p>No, protocols are compiled before execution and cannot be modified while running. This is by design to ensure complete reproducibility and data provenance. Stop the current run and start a new one with the modified protocol.</p>"},{"location":"faq/#data-and-analysis","title":"Data and Analysis","text":"Where is my data saved? <p>All run data is saved in timestamped directories under <code>data/runs/</code>. Each run includes the original protocol, compiled timing data, hardware logs, and any analog recordings.</p> What format is the logged data? <p>Data is saved in standard formats: YAML for configuration, NumPy arrays for timing data, and CSV for analog readings. This ensures compatibility with common analysis tools and long-term data accessibility.</p> How do I analyze the timing precision? <p>Use the interactive visualizer to examine the relationship between commanded and actual timing. The system logs both intended timing (from protocol) and actual hardware timing (from DAQ) for validation.</p>"},{"location":"faq/#contributing-and-support","title":"Contributing and Support","text":"I found a bug - how do I report it? <p>Please open an issue on the GitHub repository with details about your system, the protocol you were running, and the specific error or unexpected behavior.</p> Can I contribute new features? <p>Absolutely! See the Contributing Guide for information about the development process, coding standards, and how to submit pull requests.</p> Is there a user community? <p>The primary community is through GitHub issues and discussions. For neuroscience-specific questions, consider posting in relevant research forums with a link to this documentation.</p> <p>Still have questions?</p> <p>If you don't see your question here, check the detailed documentation sections or open an issue on GitHub. We're happy to help!hy separate preload and commit?**  </p> <p>A: It lets the DAQ timestamp the commit with hardware precision and coordinate multiple assemblies independently.</p> <p>Q: What does the guardrail prevent? A: Overlapping \u201cpreload\u2192commit\u201d windows (where two assemblies would both be staged). The Teensy firmware intentionally handles exactly one staged owner at a time.</p> <p>Q: Why sticky S-bits? A: They make digital rails represent current state between events, simplifying verification and downstream analysis.</p> <p>Q: Can I use 0.1 ms timing? A: Yes; set <code>sample_rate: 10000</code> and ensure your USB-6353 and host can stream the sample count. Everything (guardrails, viewer) scales.</p>"},{"location":"firmware/","title":"Teensy 4.1 Firmware","text":"<p>Model: Preload-and-commit with RCK-sense, single-owner SPI bus.</p> <ul> <li>DAQ asserts <code>*_LOAD_REQ</code> \u2192 Teensy ISR:</li> <li>Samples <code>S</code> bits for that assembly.</li> <li>Shifts the corresponding 16-bit (big) or 8-bit (small) pattern via SPI to the daisy chain (no latch).</li> <li>Sets <code>READY_*</code> high and locks the bus to that owner.</li> <li>DAQ later asserts <code>RCK_*</code> \u2192 Teensy ISR senses it:</li> <li>Drops <code>READY_*</code>, unlocks the bus.</li> </ul> <p>Only one staged preload may be pending at a time. The compiler enforces this with guardrails.</p>"},{"location":"firmware/#state-coding","title":"State coding","text":"<p>Big manifold (16-bit, using v0..v11, 4 spare):</p> <ul> <li><code>AIR</code>: v0,v1 = 1</li> <li><code>ODOR1</code>: v2,v3 = 1 \u2026  </li> <li><code>ODOR5</code>: v10,v11 = 1  </li> <li><code>FLUSH</code>: v0..v11 = 1</li> </ul> <p>Small switch (8-bit, using v0..v1):</p> <ul> <li><code>CLEAN</code>: both 0  </li> <li><code>ODOR</code>:  both 1</li> </ul> <p>Edit arrays in <code>firmware/teensy41/src/v0.ino</code> if your plumbing differs.</p>"},{"location":"hardware/","title":"System Architecture","text":"<p>The system separates state preparation from state commit:</p> <ol> <li>Teensy 4.1 drives SPI MOSI/SCK to all TPIC6B595 chains (no latches).</li> <li>NI-DAQ provides:</li> <li>Digital lines for state selection (<code>*_S0/_S1/_S2</code> or <code>*_S</code>) and LOAD_REQ.</li> <li>Register clocks (<code>RCK_*</code>) to latch TPIC outputs\u2014this is the commit moment.</li> <li>Triggers to external devices (e.g., microscope, camera).</li> <li>Analog outputs (AO) to set MFC setpoints.</li> <li>Analog inputs (AI) to read MFC flow feedback (0\u20135 V).</li> </ol> <p>Key idea: the Teensy preloads the next pattern when <code>*_LOAD_REQ</code> rises (it samples S-bits), then waits. The DAQ later asserts <code>RCK_*</code> to commit the preload. The DAQ can timestamp RCK edges precisely (hardware clock).</p>"},{"location":"hardware/#hardware-blocks","title":"Hardware Blocks","text":"<ul> <li>Valve drivers: TPIC6B595 (open-drain high-side sinking arrays).</li> <li>Big olfactometers: two 16-bit manifolds (use 12 bits now; 4 spares).</li> <li>Small switch valves: two 2-valve assemblies (8-bit register each; only 2 bits used).</li> <li>MFCs: Four channels (air L/R, odor L/R). AO setpoint (0\u20135 V), AI feedback (0\u20135 V).</li> <li>Timing: NI USB-6353 sample clock slaves AO &amp; AI to DO.</li> </ul>"},{"location":"hardware/#signal-naming-logical","title":"Signal Naming (logical)","text":"<p>Digital outputs (from DAQ to Teensy/TPIC):</p> <ul> <li>Left big olfactometer: <code>OLFACTOMETER_LEFT_S0/_S1/_S2</code>, <code>OLFACTOMETER_LEFT_LOAD_REQ</code>, <code>RCK_OLFACTOMETER_LEFT</code></li> <li>Right big olfactometer: <code>OLFACTOMETER_RIGHT_*</code> (same fields)</li> <li>Left small switch: <code>SWITCHVALVE_LEFT_S</code>, <code>SWITCHVALVE_LEFT_LOAD_REQ</code>, <code>RCK_SWITCHVALVE_LEFT</code></li> <li>Right small switch: <code>SWITCHVALVE_RIGHT_*</code></li> <li>Triggers: <code>TRIG_MICRO</code>, <code>TRIG_CAMERA</code></li> </ul> <p>Analog:</p> <ul> <li>AO (setpoints): <code>mfc.air_left_setpoint</code>, <code>mfc.air_right_setpoint</code>, <code>mfc.odor_left_setpoint</code>, <code>mfc.odor_right_setpoint</code></li> <li>AI (feedback): <code>mfc.air_left_flowrate</code>, <code>mfc.air_right_flowrate</code>, <code>mfc.odor_left_flowrate</code>, <code>mfc.odor_right_flowrate</code></li> </ul>"},{"location":"logging/","title":"Logging &amp; Artifacts","text":"<p>Each run creates a folder: <code>data/runs/YYYY-MM-DD_HH-MM-SS/</code> with:</p> <ul> <li><code>meta.json</code>: device, sample rate, duration, rng_seed, CLI args.</li> <li><code>protocol.yaml</code>, <code>hardware.yaml</code>: copies of inputs for provenance.</li> <li><code>do_map.json</code>, <code>ao_map.json</code>: logical names \u2192 physical channels.</li> <li><code>compiled_do.npz</code>: boolean array <code>[lines, samples]</code>.</li> <li><code>compiled_ao.npz</code>: float array <code>[channels, samples]</code>.</li> <li><code>capture_ai.npz</code>: (optional) float array <code>[channels, samples]</code> with MFC feedback.</li> <li><code>rck_edges.csv</code>: planned commits (<code>signal, sample_idx, time_ms</code>).</li> <li><code>digital_edges.csv</code>: all rising/falling edges for every DO line.</li> <li><code>preview.html</code>: interactive Plotly visualization.</li> </ul> <p>You can parse <code>digital_edges.csv</code> to compute inter-event latencies and export tabular summaries alongside imaging data.</p>"},{"location":"protocol/","title":"YAML Protocol Specification","text":"<p>This document describes the YAML protocol format for defining olfactometer experiments with precise timing control.</p>"},{"location":"protocol/#protocol-structure-overview","title":"Protocol Structure Overview","text":"<p>A protocol consists of three main sections:</p> <ul> <li>Protocol metadata: Name, version, and description</li> <li>Timing configuration: Sample rates, pulse widths, and timing constraints</li> <li>Sequence definition: Phases with device actions and precise timing</li> </ul>"},{"location":"protocol/#top-level-configuration","title":"Top-Level Configuration","text":"<pre><code>protocol:\n  name: \"Descriptive Protocol Name\"\n  version: \"1.0\"\n  description: \"Detailed description of the experimental paradigm\"\n  timing:\n    base_unit: \"ms\"                    # Time unit for all timing values\n    sample_rate: 1000                  # Hz - 1000=1ms precision, 10000=0.1ms precision\n    camera_interval: 100               # ms - interval between camera pulses (0=disabled)\n    camera_pulse_duration: 5           # ms - duration of camera trigger pulses\n    preload_lead_ms: 2                 # ms - S-bits switch before LOAD_REQ pulse\n    load_req_ms: 1                     # ms - duration of LOAD_REQ pulses\n    rck_pulse_ms: 1                    # ms - duration of register clock (RCK) pulses\n    trig_pulse_ms: 5                   # ms - duration of microscope trigger pulses\n    setup_hold_samples: 100            # samples - S-bit stability margin around load events\n    seed: 42                           # RNG seed for reproducible randomization (optional)\n\nsequence:\n  - phase: \"Phase Name\"\n    duration: 30000                    # ms - total phase duration\n    times: 5                           # number of repetitions (preferred over 'repeat')\n    repeat: 0                          # legacy: 0=no repeat, 1=repeat once\n    randomize: true                    # randomize order within state lists\n    actions:\n      - device: \"device.name\"\n        state: \"STATE_NAME\"            # for digital devices\n        value: 2.5                     # for analog devices (volts)\n        timing: 1000                   # ms - offset within phase\n</code></pre>"},{"location":"protocol/#timing-configuration-details","title":"Timing Configuration Details","text":""},{"location":"protocol/#sample-rate-precision","title":"Sample Rate &amp; Precision","text":"<ul> <li>sample_rate: Determines temporal resolution</li> <li><code>1000</code> Hz = 1 ms precision (standard)</li> <li><code>10000</code> Hz = 0.1 ms precision (high precision)</li> <li>base_unit: Always \"ms\" for millisecond timing</li> </ul>"},{"location":"protocol/#hardware-pulse-timing","title":"Hardware Pulse Timing","text":"<ul> <li>preload_lead_ms: Time before LOAD_REQ when S-bits switch to new state</li> <li>load_req_ms: Duration of load request pulses sent to Teensy</li> <li>rck_pulse_ms: Duration of register clock pulses for valve commits</li> <li>setup_hold_samples: Extra samples for S-bit stability around load events</li> </ul>"},{"location":"protocol/#camera-trigger-timing","title":"Camera &amp; Trigger Timing","text":"<ul> <li>camera_interval: Interval between continuous camera pulses (0 = disabled)</li> <li>camera_pulse_duration: Width of camera trigger pulses</li> <li>trig_pulse_ms: Width of microscope trigger pulses</li> </ul>"},{"location":"protocol/#device-types-states","title":"Device Types &amp; States","text":""},{"location":"protocol/#device-configuration-reference","title":"Device Configuration Reference","text":""},{"location":"protocol/#olfactometers-8-valve-systems","title":"Olfactometers (8-Valve Systems)","text":"<p>Control large olfactometer valve arrays with 8 possible states.</p> <p>Device Keys:</p> <ul> <li><code>olfactometer.left</code> - Left olfactometer system</li> <li><code>olfactometer.right</code> - Right olfactometer system</li> </ul> <p>Available States:</p> <ul> <li><code>OFF</code> - All valves closed (state 0)</li> <li><code>AIR</code> - Clean air delivery (state 1)</li> <li><code>ODOR1</code> through <code>ODOR5</code> - Specific odor channels (states 2-6)</li> <li><code>FLUSH</code> - System flush/clean (state 7)</li> </ul> <p>Multi-State Selection:</p> <pre><code># Single state\nstate: \"ODOR1\"\n\n# Sequential selection (uses repeat index)  \nstate: \"ODOR1,ODOR2,ODOR3\"\n\n# Copy from other side\nstate: \"COPY\"  # mirrors the resolved left olfactometer state\n</code></pre>"},{"location":"protocol/#switch-valves-2-state-systems","title":"Switch Valves (2-State Systems)","text":"<p>Control binary switch valves for clean/odor selection.</p> <p>Device Keys:</p> <ul> <li><code>switch_valve.left</code> - Left switch valve</li> <li><code>switch_valve.right</code> - Right switch valve  </li> </ul> <p>Available States:</p> <ul> <li><code>CLEAN</code> - Clean air path (state 0)</li> <li><code>ODOR</code> - Odor delivery path (state 1)</li> </ul>"},{"location":"protocol/#mass-flow-controllers-analog-outputs","title":"Mass Flow Controllers (Analog Outputs)","text":"<p>Set voltage levels (0-5V) for MFC setpoints.</p> <p>Device Keys:</p> <ul> <li><code>mfc.air_left_setpoint</code> - Left air MFC setpoint</li> <li><code>mfc.air_right_setpoint</code> - Right air MFC setpoint</li> <li><code>mfc.odor_left_setpoint</code> - Left odor MFC setpoint  </li> <li><code>mfc.odor_right_setpoint</code> - Right odor MFC setpoint</li> </ul> <p>Usage:</p> <pre><code>- device: \"mfc.air_left_setpoint\"\n  value: 2.1  # Volts (typically 0-5V range)\n  timing: 1000\n</code></pre>"},{"location":"protocol/#trigger-signals","title":"Trigger Signals","text":"<p>Generate precise trigger pulses for external equipment.</p> <p>Device Keys:</p> <ul> <li><code>triggers.microscope</code> - Single pulse triggers for microscope</li> <li><code>triggers.camera_continuous</code> - Continuous periodic camera triggers</li> </ul> <p>Microscope Triggers:</p> <pre><code># Single pulse at specified timing\n- device: \"triggers.microscope\" \n  state: true\n  timing: 30000  # Pulse occurs at 30s mark\n</code></pre> <p>Camera Triggers:</p> <pre><code># Start continuous pulses\n- device: \"triggers.camera_continuous\"\n  state: true\n  timing: 1000\n\n# Stop continuous pulses  \n- device: \"triggers.camera_continuous\"\n  state: false\n  timing: 60000\n</code></pre>"},{"location":"protocol/#sequence-definition","title":"Sequence Definition","text":""},{"location":"protocol/#phase-structure","title":"Phase Structure","text":"<p>Each phase represents a distinct experimental period with defined duration and actions.</p> <pre><code>- phase: \"Descriptive Phase Name\"\n  duration: 30000        # Total phase duration in ms\n  times: 5               # Number of repetitions (recommended)\n  repeat: 0              # Legacy: 0=no repeat, 1=repeat once  \n  randomize: true        # Randomize state order within lists\n  actions:               # List of device actions\n    - device: \"device.name\"\n      state: \"STATE\"\n      timing: 1000       # Offset within phase (ms)\n</code></pre>"},{"location":"protocol/#action-timing","title":"Action Timing","text":"<p>All action timing is relative to the start of each phase repetition.</p> <p>Example Timeline:</p> <pre><code>- phase: \"Trial Phase\"\n  duration: 60000  # 60 second phase\n  times: 3         # Repeat 3 times\n  actions:\n    - device: \"olfactometer.left\"\n      state: \"ODOR1\"\n      timing: 0        # At phase start: 0s, 60s, 120s\n    - device: \"triggers.microscope\"  \n      state: true\n      timing: 30000    # Mid-phase: 30s, 90s, 150s\n</code></pre>"},{"location":"protocol/#randomization","title":"Randomization","text":"<p>When <code>randomize: true</code> and multi-state lists are provided:</p> <pre><code>- phase: \"Randomized Odors\"\n  times: 4\n  randomize: true\n  actions:\n    - device: \"olfactometer.left\"\n      state: \"ODOR1,ODOR2,ODOR3,ODOR4\"  # Will be shuffled each protocol run\n      timing: 0\n</code></pre> <p>The <code>seed</code> parameter in timing configuration ensures reproducible randomization.</p>"},{"location":"protocol/#advanced-features","title":"Advanced Features","text":""},{"location":"protocol/#state-copying","title":"State Copying","text":"<p>The right olfactometer can mirror the left side's resolved state:</p> <pre><code>- device: \"olfactometer.left\" \n  state: \"ODOR1,ODOR2,ODOR3\"\n  timing: 0\n- device: \"olfactometer.right\"\n  state: \"COPY\"  # Uses same resolved state as left\n  timing: 100    # Slight delay for timing control\n</code></pre>"},{"location":"protocol/#precise-timing-control","title":"Precise Timing Control","text":"<p>Hardware Constraints:</p> <ul> <li>S-bits switch <code>preload_lead_ms</code> before LOAD_REQ pulses</li> <li><code>setup_hold_samples</code> provide stability margins around load events</li> <li>Overlapping preload windows are detected and rejected at compile time</li> </ul> <p>Timing Guardrails: The compiler enforces timing constraints to prevent hardware conflicts and ensure reliable valve switching.</p>"},{"location":"protocol/#complete-example","title":"Complete Example","text":"<pre><code>protocol:\n  name: \"Odor Discrimination Task\"\n  timing:\n    sample_rate: 1000\n    seed: 42\n\nsequence:\n  - phase: \"Baseline\"\n    duration: 30000\n    times: 1\n    actions:\n      - device: \"olfactometer.left\"\n        state: \"AIR\"\n        timing: 0\n      - device: \"triggers.camera_continuous\"\n        state: true  \n        timing: 1000\n\n  - phase: \"Odor Presentation\"\n    duration: 60000\n    times: 5\n    randomize: true\n    actions:\n      - device: \"olfactometer.left\"\n        state: \"ODOR1,ODOR2,ODOR3,ODOR4,ODOR5\"\n        timing: 0\n      - device: \"switch_valve.left\"\n        state: \"ODOR\"\n        timing: 10000\n      - device: \"triggers.microscope\"\n        state: true\n        timing: 15000\n</code></pre>"},{"location":"runner/","title":"Protocol Runner (NI-DAQ Application)","text":"<p>The protocol runner compiles YAML protocol files, generates hardware-clocked digital/analog outputs, and captures analog input feedback from mass flow controllers (MFCs).</p>"},{"location":"runner/#dependencies","title":"Dependencies","text":"<ul> <li>NI-DAQmx driver and Python API (<code>pip install nidaqmx</code>)</li> <li>Core libraries: numpy, pyyaml, plotly (for visualization)</li> <li>Poetry environment (recommended): <code>poetry install</code></li> </ul>"},{"location":"runner/#command-line-interface","title":"Command Line Interface","text":""},{"location":"runner/#dry-run-preview-only","title":"Dry Run (Preview Only)","text":"<pre><code># Generate preview without hardware execution\npython -m multibios.run_protocol \\\n  --yaml config/example_protocol.yaml \\\n  --hardware config/hardware.yaml \\\n  --dry-run --seed 42\n</code></pre>"},{"location":"runner/#hardware-execution","title":"Hardware Execution","text":"<pre><code># Execute protocol on DAQ hardware\npython -m multibios.run_protocol \\\n  --yaml config/example_protocol.yaml \\\n  --hardware config/hardware.yaml\n</code></pre>"},{"location":"runner/#command-line-options","title":"Command Line Options","text":""},{"location":"runner/#core-arguments","title":"Core Arguments","text":"<ul> <li><code>--yaml &lt;file&gt;</code>: Protocol YAML file (default: <code>config/example_protocol.yaml</code>)</li> <li><code>--hardware &lt;file&gt;</code>: Hardware mapping YAML (default: <code>config/hardware.yaml</code>)</li> <li><code>--device &lt;name&gt;</code>: Override DAQ device name from hardware.yaml</li> <li><code>--dry-run</code>: Compile and preview only, no hardware execution</li> <li><code>--out-root &lt;dir&gt;</code>: Output directory root (default: <code>data/runs</code>)</li> </ul>"},{"location":"runner/#timing-overrides","title":"Timing Overrides","text":"<ul> <li><code>--seed &lt;int&gt;</code>: Override <code>protocol.timing.seed</code> for reproducible randomization</li> <li><code>--preload-lead-ms &lt;int&gt;</code>: Override preload lead time</li> <li><code>--load-req-ms &lt;int&gt;</code>: Override load request pulse duration  </li> <li><code>--rck-ms &lt;int&gt;</code>: Override register clock pulse duration</li> <li><code>--trig-ms &lt;int&gt;</code>: Override trigger pulse duration</li> </ul>"},{"location":"runner/#visualization","title":"Visualization","text":"<ul> <li><code>--interactive</code>: Always save interactive HTML preview (enabled by default)</li> </ul>"},{"location":"runner/#daq-clocking-architecture","title":"DAQ Clocking Architecture","text":"<ul> <li>Digital Output (DO): Master clock - provides <code>SampleClock</code> and <code>StartTrigger</code></li> <li>Analog Output (AO): Slave - synchronized to DO clock</li> <li>Analog Input (AI): Slave - synchronized to DO clock for MFC feedback capture</li> </ul>"},{"location":"runner/#output-files","title":"Output Files","text":"<p>Each run creates a timestamped directory in <code>data/runs/YYYY-MM-DD_HH-MM-SS/</code>:</p> <ul> <li><code>preview.html</code>: Interactive Plotly visualization</li> <li><code>compiled_do.npz</code>: Digital output arrays</li> <li><code>compiled_ao.npz</code>: Analog output arrays  </li> <li><code>capture_ai.npz</code>: Analog input data (if hardware run)</li> <li><code>do_map.json</code>, <code>ao_map.json</code>: Channel mapping information</li> <li><code>rck_edges.csv</code>: Register clock commit timestamps</li> <li><code>digital_edges.csv</code>: All digital signal edge transitions</li> <li><code>protocol.yaml</code>, <code>hardware.yaml</code>: Input file copies</li> <li><code>meta.json</code>: Run metadata and parameters</li> </ul>"},{"location":"runner/#post-run-visualization","title":"Post-Run Visualization","text":"<p>Use the visualization tool to re-analyze saved runs:</p> <pre><code># Re-visualize a completed run\npython -m multibios.viz_protocol data/runs/2025-08-21_16-25-26\n</code></pre> <p>This generates an updated <code>preview.html</code> with the same device-grouped visualization as the runner.</p>"},{"location":"safety/","title":"Safety Notes","text":"<ul> <li>Teensy 4.1 is 3.3 V-only (GPIOs are not 5 V tolerant). If DAQ DO lines are 5 V, use level shifters or opto-isolators (open-collector + pull-ups to 3.3 V).</li> <li>Flyback protection: TPIC6B595 drives inductive loads (valves). Keep TPIC SR outputs with proper transient suppression per datasheet (integrated diodes help, but add bulk capacitance near loads).</li> <li>Grounding: DAQ GND, Teensy GND, and TPIC logic GND must share a stable reference. Avoid ground loops across long runs; star topology recommended.</li> <li>Power rails: Size 24 V supply for worst-case concurrent valves + headroom. Add bulk caps near manifolds.</li> <li>EMI: Route RCK and S-lines away from noisy solenoid conductors. Use twisted pairs and shielding where feasible.</li> </ul>"},{"location":"timing/","title":"Timing Model, Sticky S-bits &amp; Guardrails","text":""},{"location":"timing/#event-anatomy","title":"Event anatomy","text":"<p>For a single assembly (e.g., left big olfactometer):</p> <ul> <li>Switch (S-bits change) at <code>t_switch = t_commit - preload_lead_ms</code> (minus a few setup samples).</li> <li>Preload window: <code>[*_LOAD_REQ]</code> pulse at <code>t_load = t_switch + setup_hold</code>.</li> <li>Commit window end: <code>[*_RCK]</code> pulse at <code>t_commit</code>.</li> </ul> <p>The compiler rejects any overlapping windows across assemblies: Window = [t_load, t_rck + rck_width]</p>"},{"location":"timing/#sticky-s-bits","title":"Sticky S-bits","text":"<ul> <li>S-bits reflect the current state from the last commit until <code>t_switch</code> for the next state.  </li> <li>Between <code>t_switch</code> and <code>t_commit</code>, S-bits show the upcoming state (so the Teensy samples the correct code at <code>LOAD_REQ</code>).  </li> <li>This makes the digital rails self-describing and easy to read in the viewer.</li> </ul>"},{"location":"timing/#practical-guidance","title":"Practical guidance","text":"<ul> <li>If guardrails trip, increase separation between events or adjust <code>preload_lead_ms</code>, <code>load_req_ms</code>, or <code>rck_pulse_ms</code>.</li> <li>For 0.1 ms precision, set <code>sample_rate: 10000</code>. Ensure NI-DAQ CPU/USB bandwidth is sufficient for your total sample count.</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#compile-time","title":"Compile-time","text":"<ul> <li>Overlapping pre-load windows</li> <li>Error shows two labeled windows with times.</li> <li> <p>Increase spacing between commits, or increase <code>preload_lead_ms</code>.</p> </li> <li> <p>Unknown device/channel</p> </li> <li>Ensure the device key exists in <code>hardware.yaml</code> and matches schema expectations.</li> </ul>"},{"location":"troubleshooting/#run-time","title":"Run-time","text":"<ul> <li>AI capture missing</li> <li>Check <code>analog_inputs</code> in <code>hardware.yaml</code>.</li> <li> <p>Ensure DO is master clock and AI slaves to <code>/&lt;Dev&gt;/do/SampleClock</code>.</p> </li> <li> <p>No latching / valves don\u2019t change</p> </li> <li>Confirm DAQ actually toggles <code>*_LOAD_REQ</code> and <code>RCK_*</code>.</li> <li>Confirm Teensy READY LEDs (optional pins) assert during preload and drop on RCK.</li> <li> <p>Verify level shifting to Teensy (3.3 V).</p> </li> <li> <p>MFC feedback saturates</p> </li> <li>Confirm <code>ai</code> voltage range (set \u00b110 V is fine for 0\u20135 V signals).</li> <li> <p>Check wiring and common ground.</p> </li> <li> <p>Viewer shows nothing</p> </li> <li>Open the run folder and check that <code>compiled_do.npz</code> and <code>preview.html</code> were created.</li> </ul>"},{"location":"validation/","title":"Validation &amp; QA","text":""},{"location":"validation/#functional-tests-no-valves","title":"Functional tests (no valves)","text":"<ol> <li>Preview compile <code>python -m multibios.run_protocol --yaml config/example_protocol.yaml --hardware config/hardware.yaml --dry-run --interactive --seed 1</code></li> <li> <p>Inspect <code>preview.html</code>. Confirm state rails read sensibly; RCK markers align to commits.</p> </li> <li> <p>Guardrail test    Create two actions with commits closer than <code>preload_lead_ms + max(load_req_ms,rck_pulse_ms)</code> and confirm the compiler raises a helpful error.</p> </li> <li> <p>Randomization reproducibility    Run twice with the same <code>--seed</code> and confirm:</p> </li> <li>Identical <code>digital_edges.csv</code></li> <li>Identical <code>preview.html</code> (modulo timestamps in <code>meta.json</code>)</li> </ol>"},{"location":"validation/#hardware-tests-with-mfc-loopback-or-live-mfcs","title":"Hardware tests (with MFC loopback or live MFCs)","text":"<ol> <li>MFC AO/AI tracking</li> <li>Step <code>mfc.*_setpoint</code> and verify <code>AI</code> tracks setpoint in <code>preview.html</code>.</li> <li> <p>Optional: add per-channel scales (V\u2192sccm) and check steady-state error &lt; your tolerance.</p> </li> <li> <p>Latency sanity</p> </li> <li> <p>Use the viewer\u2019s vertical rulers and hover readouts to confirm spacing between S-bit switch, LOAD_REQ, and RCK matches YAML timing.</p> </li> <li> <p>Valve drive sanity (dry run) </p> </li> <li>Disconnect 24 V loads; probe RCK &amp; S-lines for clean edges and no ringing.</li> </ol>"},{"location":"visualization/","title":"Visualization (Interactive)","text":"<p>Each run writes <code>preview.html</code> with Plotly:</p> <ul> <li>Row 1 (digital): all DO rails stacked: state lines (<code>*_S*</code>), <code>*_LOAD_REQ</code>, <code>RCK_*</code>, and triggers.</li> <li>Hover shows <code>time (ms)</code> and logic level.</li> <li>Pale red vertical lines mark each <code>RCK_*</code> commit.</li> <li>Row 2 (AO): MFC setpoints (step traces).</li> <li>Row 3 (AI): MFC feedback (if captured).</li> </ul> <p>Use the legend to toggle visibility; drag to zoom; double-click to reset.</p>"},{"location":"wiring/","title":"Hardware Wiring &amp; Pin Configuration","text":"<p>This document describes the electrical connections between the NI DAQ system and the Teensy 4.1 microcontroller for valve control.</p>"},{"location":"wiring/#daq-channel-mapping","title":"DAQ Channel Mapping","text":"<p>Configure your DAQ channels in <code>config/hardware.yaml</code>:</p> <pre><code>device: \"Dev1\"\ndigital_outputs:\n  OLFACTOMETER_LEFT_S0:        \"Dev1/port0/line0\"\n  OLFACTOMETER_LEFT_S1:        \"Dev1/port0/line1\"\n  OLFACTOMETER_LEFT_S2:        \"Dev1/port0/line2\"\n  OLFACTOMETER_LEFT_LOAD_REQ:  \"Dev1/port0/line3\"\n  RCK_OLFACTOMETER_LEFT:       \"Dev1/port0/line4\"\n  OLFACTOMETER_RIGHT_S0:       \"Dev1/port0/line5\"\n  OLFACTOMETER_RIGHT_S1:       \"Dev1/port0/line6\"\n  OLFACTOMETER_RIGHT_S2:       \"Dev1/port0/line7\"\n  OLFACTOMETER_RIGHT_LOAD_REQ: \"Dev1/port0/line8\"\n  RCK_OLFACTOMETER_RIGHT:      \"Dev1/port0/line9\"\n  SWITCHVALVE_LEFT_S:          \"Dev1/port0/line10\"\n  SWITCHVALVE_LEFT_LOAD_REQ:   \"Dev1/port0/line11\"\n  RCK_SWITCHVALVE_LEFT:        \"Dev1/port0/line12\"\n  SWITCHVALVE_RIGHT_S:         \"Dev1/port0/line13\"\n  SWITCHVALVE_RIGHT_LOAD_REQ:  \"Dev1/port0/line14\"\n  RCK_SWITCHVALVE_RIGHT:       \"Dev1/port0/line15\"\n  TRIG_MICRO:                  \"Dev1/port0/line16\"\n  TRIG_CAMERA:                 \"Dev1/port0/line17\"\n\nanalog_outputs:\n  mfc.air_left_setpoint:   \"Dev1/ao0\"\n  mfc.air_right_setpoint:  \"Dev1/ao1\"\n  mfc.odor_left_setpoint:  \"Dev1/ao2\"\n  mfc.odor_right_setpoint: \"Dev1/ao3\"\n\nanalog_inputs:\n  mfc.air_left_flowrate:   \"Dev1/ai0\"\n  mfc.air_right_flowrate:  \"Dev1/ai1\"\n  mfc.odor_left_flowrate:  \"Dev1/ai2\"\n  mfc.odor_right_flowrate: \"Dev1/ai3\"\n</code></pre>"},{"location":"wiring/#teensy-41-pin-configuration","title":"Teensy 4.1 Pin Configuration","text":"<p>SPI Communication:</p> <ul> <li>MOSI = Pin 11</li> <li>SCK = Pin 13</li> </ul> <p>RCK Sense Inputs (from DAQ):</p> <ul> <li>Olfactometer Left = Pin 2</li> <li>Olfactometer Right = Pin 3  </li> <li>Switch Valve Left = Pin 4</li> <li>Switch Valve Right = Pin 5</li> </ul> <p>Ready Signal Outputs (optional monitoring):</p> <ul> <li>Olfactometer Left = Pin 6</li> <li>Olfactometer Right = Pin 7</li> <li>Switch Valve Left = Pin 8  </li> <li>Switch Valve Right = Pin 9</li> </ul> <p>State Input Pins (from DAQ):</p> <ul> <li>Olfactometer Left: S0=Pin 14, S1=Pin 15, S2=Pin 16</li> <li>Olfactometer Right: S0=Pin 17, S1=Pin 18, S2=Pin 19</li> <li>Switch Valve Left: S=Pin 20</li> <li>Switch Valve Right: S=Pin 21</li> </ul> <p>Load Request Inputs (from DAQ):</p> <ul> <li>Olfactometer Left = Pin 22</li> <li>Olfactometer Right = Pin 23</li> <li>Switch Valve Left = Pin 24</li> <li>Switch Valve Right = Pin 25</li> </ul> <p>Wiring Notes:</p> <ul> <li>Connect DAQ RCK output lines to corresponding Teensy RCK sense inputs</li> <li>Keep all grounds common between DAQ and Teensy</li> <li>Use level shifters if DAQ outputs 5V (Teensy inputs are 3.3V tolerant)</li> <li>Label panel connections with descriptive names (not A/B/C/D)</li> </ul>"}]}